You are a robot operating in an environment with the following state

CATEGORIES = ["block"]
TABLE_BOUNDS = [[-0.55, 0.55], [-0.6, 0.6], [0, 0]]  # X Y Z
TABLE_CENTER = [0, 0, 0]
BLOCK_DIMENSIONS = [0.04, 0.04, 0.12]

@dataclass
class RavenPose:
    x: float = 0
    y: float = 0
    z: float = 0
    roll: float = 0
    pitch: float = 0
    yaw: float = 0

    @property
    def point(self):
        ...
    
    @property
    def euler(self):
        ...

@dataclass
class RavenObject:
    category: str
    color: str
    pose: RavenPose = field(default_factory=lambda: RavenPose())
    body: Optional[int] = None

@dataclass
class RavenBelief:
    objects: Dict[str, RavenObject] = field(default_factory=dict)
    observations: List[Any] = field(default_factory=list)

@dataclass
class ContinuousSampler:
    min: float = 0
    max: float = 1

    def sample(self):
        return random.uniform(self.min, self.max)

@dataclass
class DiscreteSampler:
    values: List[int]

    def sample(self):
        return random.choice(self.values)

@dataclass
class Action:
    name: str
    params: List[float]

@dataclass
class GraspSampler(Sampler):
    def sample(self) -> RavenGrasp:
        ...

You have access to the following set of skills expressed as pddl predicates followed by descriptions. 
You have no other skills you can use, and you must exactly follow the number of inputs described below.
The coordinate axes are x, y, z where x is left/right from the robot base, x is distance from the robot base, and z is the height off the table.

Action("pick", [o, g])
Pick up object o at grasp g sampled from a grasp sampler. Grasps MUST come from grasp samplers.

Action("place", [o, g, p])
If holding an object o at grasp g, place the object at pose p.

Action("getObj", [o, g, p])
If holding an object o at grasp g, place the object at pose p.

Action("place", [o, g, p])
If holding an object o at grasp g, place the object at pose p.

pick(object_name: str)
- Generates a motion plan to pick an object
- Parameters:
  - object_name (str): The frame name of the object to be picked.

place(x: float, y: float, z: float=.0, roll: float=None, pitch: float=None, yaw: float=None)
- Generates a place motion of the robot's object in hand
- Parameters:
  - x (float): Target position on the x axis.
  - y (float): Target position on the y axis.
  - z (float)(default: 0): Target position on the z axis, if 0 it will be on top of the table.
  - roll (float)(default: None): Target roll (if any).
  - pitch (float)(default: None): Target pitch (if any).
  - yaw (float)(default: None): Target yaw (if any).

push(object_name: str, relative_x: float, relative_y: float)
- Generates a motion plan to push an object towards a relative position to the object
- Parameters:
  - object_name (str): The frame name of the object to be pushed.
  - relative_x (float): The relative target position on the x axis.
  - relative_y (float): The relative target position on the y axis.

getObj(object_name: str)
- Returns an object from which you can query the following parameters: pos.x, pos.y, pos.z, size.x, size.y, size.z
  - object_name (str): The frame name of the object to be queried.

set_grabbed_frame_pose(x: float=None, y: float=None, z: float=None, roll: float=None, pitch: float=None, yaw: float=None)
- Sets the pose of a grabbed frame. Requires to first pick up a frame.
  - x (float)(default: None): Target position on the x axis.
  - y (float)(default: None): Target position on the y axis.
  - z (float)(default: None): Target position on the z axis, if 0 it will be on top of the table.
  - roll (float)(default: None): Target roll (if any).
  - pitch (float)(default: None): Target pitch (if any).
  - yaw (float)(default: None): Target yaw (if any).

Your goal is to generate the following:

First, generate a python function named `gen_plan` that can take any discrete or continuous inputs. No list inputs are allowed.
and return the entire plan with all steps included where the parameters to the plan depend on the inputs.

Second, generate a python function `gen_domain` that returns a set of bounds for the continuous or discrete input parameters. The number of bounds in the
generated domain should exactly match the number of inputs to the function excluding the state input

The function you give should always achieve the goal regardless of what parameters from the domain are passed as input. 
The `gen_plan` function therefore defines a family of solutions to the problem. Explain why the function will always satisfy the goal regardless of the input parameters.
Make sure your function inputs allow for as much variability in output plan as possible while still achieving the goal.
Your function should be as general as possible such that any correct answer corresponds to some input parameters to the function.

All of these parameter samples may fail, in which case it will return feedback about what constraints caused the failure.
In the event of a constraint satisfaction fail, explain what went wrong and then return an updated gen_plan and gen_domain that fixes the issue. 
This may involve adding actions to the beginning of the plan to move obstructing objects leading to collisions and adding new continuous input parameters that are used for those new actions.
Do not add complex logic or too much extra code to fix issues due to constraint violations.

The main function should be named EXACTLY `gen_plan` and the domain of the main function should be named EXACTLY `gen_domain`. Do not change the names. Do not create any additional classes or overwrite any existing ones.
Aside from the inital state all inputs to the `gen_plan` function MUST NOT be of type List or Dict. List and Dict inputs to `gen_plan` are not allowed.
Additionally, the input to `gen_domain` must be exactly the `initial:RavenBelief` argument, even if this isn't explicitly used within the function!
